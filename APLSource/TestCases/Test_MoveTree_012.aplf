 R←Test_MoveTree_012(stopFlag batchFlag);⎕TRAP;rc;more;list;successFlag;success;tempPathSource;tempPathTarget;filename;tno;record;en;fqn;row;noOf2;sourceList;targetList;F;noOf_1a;noOf_1b
⍝ Exercise `MoveTree`: move a tree of dirs and files with one file tied exclusively
 ⎕TRAP←(999 'C' '. ⍝ Deliberate error')(0 'N')
 R←∆Failed

 :If 'Win'≢#.APLTreeUtils.GetOperatingSystem ⍬
     R←∆WindowsOnly
     :Return
 :Else

     F←##.FilesAndDirs
     tempPathSource←F.GetTempPath,'source_',↑⎕SI
     tempPathTarget←F.GetTempPath,'target_',↑⎕SI
     (rc en more)←F.RmDir tempPathSource
     Assert 0=rc
     (rc en more)←F.RmDir tempPathTarget
     Assert 0=rc
     ∆CreateDirsAndFiles tempPathSource
     filename←F.NormalizePath'Second/Sub_a/file_third.dcf'
     fqn←F.NormalizePath tempPathSource,'/',filename   ⍝ fully qualified name
     F.DeleteFile fqn
     tno←fqn ⎕FCREATE 0     ⍝ Implies exclusive tie: this one can be neither copied nor deleted
     noOf_1a←≢sourceList←↑('recursive' 1)F.Dir tempPathSource,'\'

     (success more list)←tempPathSource F.MoveTree tempPathTarget
     →GoToTidyUp 0≠success
     →GoToTidyUp 0≠≢more
     →GoToTidyUp 1≠list[;1]+.≠0         ⍝ Because one failed!
     noOf2←≢targetList←↑('recursive' 1)F.Dir tempPathTarget,'\'
     noOf_1b←≢sourceList←↑('recursive' 1)F.Dir tempPathSource,'\'
     →GoToTidyUp noOf_1a≠1+noOf2        ⍝ The one missing is "fqn"!
     →GoToTidyUp noOf_1b≠3              ⍝ The file and its directories
     row←filename(#.APLTreeUtils.Lowercase{↑#.APLTreeUtils.Where((-≢⍺)↑¨⍺⍺ ⍵)≡¨⊂⍺⍺ ⍺})list[;0]
     →GoToTidyUp 0=≢2⊃list[row;]

     R←∆OK

 :EndIf

∆TidyUp:
 :Trap 0 ⋄ ⎕FUNTIE tno ⋄ :EndTrap
 :Trap 0
     {}F.RmDir tempPathSource
     {}F.RmDir tempPathTarget
 :EndTrap
